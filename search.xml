<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构(一)</title>
      <link href="/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
      <url>/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念引入：存储结构-x2F-物理结构，时间-x2F-空间复杂度"><a href="#一、基本概念引入：存储结构-x2F-物理结构，时间-x2F-空间复杂度" class="headerlink" title="一、基本概念引入：存储结构&#x2F;物理结构，时间&#x2F;空间复杂度"></a>一、基本概念引入：存储结构&#x2F;物理结构，时间&#x2F;空间复杂度</h2><p>数据元素与数据元素间有两种结构：逻辑结构，存储结构&#x2F;物理结构</p><img src="https://picbed.koko2pp.cc/f92ec4a8ca52cafb9f5ca5fb9560671.png" alt="f92ec4a8ca52cafb9f5ca5fb9560671" style="zoom:67%;" /><p><strong>逻辑结构</strong>分类：</p><ul><li><p><strong>线性结构</strong>（线性表、栈、队列、串，有且仅有一个前趋和后继）；<strong>非线性结构</strong>（树、图，有多个前趋和后继）</p></li><li><p>四类基本逻辑结构：集合结构；线性结构(1v1)；树形结构( 1v多)；图状结构(多v多)</p></li></ul><p><strong>存储结构</strong>分类：</p><ul><li><strong>顺序存储结构</strong>(用存储先后位置表示逻辑先后关系)；<strong>链式存储结构</strong>(任意存储位置，但有指针表示前后逻辑关系)；索引存储结构；散列存储结构；</li></ul><p><strong>对比不同算法</strong>：时间空间复杂度，即时间和空间增长的趋势</p><ul><li><p><strong>时间渐进复杂度</strong></p><p>(BigO: 当一个问题量级增加的时候，<u>时间增长的趋势)</u>：T(n) &#x3D; O(f(n))，其中f(n)代表代码执行次数，O表示正比例关系<br><strong>Eg: O(n)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若n = 3:</span></span><br><span class="line"><span class="comment">//1. int i = 1;</span></span><br><span class="line"><span class="comment">//2. i&lt;=n;</span></span><br><span class="line"><span class="comment">//3. x++;</span></span><br><span class="line"><span class="comment">//4. i++; (i=2)</span></span><br><span class="line"><span class="comment">//5. i&lt;=n;</span></span><br><span class="line"><span class="comment">//6. x++;</span></span><br><span class="line"><span class="comment">//7. i++; (i=3)</span></span><br><span class="line"><span class="comment">//8. i&lt;=n;</span></span><br><span class="line"><span class="comment">//9. x++;</span></span><br><span class="line"><span class="comment">//10.i++;</span></span><br><span class="line"><span class="comment">//11.i&lt;=n → 退出</span></span><br><span class="line"><span class="comment">//执行次数为：i=1 执行一次； x++ i++ 会执行 n次，i&lt;=n执行n+1次，因此f(n) = 3n+2</span></span><br><span class="line"><span class="comment">//O(f(n)) = O(3n+2) =O(n),n接近于无限大的比例，常数和倍数意义不大，因此简略为O(n)</span></span><br></pre></td></tr></table></figure><p><strong>Eg: O(n<sup>2</sup>)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n; j++)&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理，O(f(n)) = O(n^2)</span></span><br></pre></td></tr></table></figure><ul><li><p>常用时间复杂度量级</p><img src="https://picbed.koko2pp.cc/image-20230107174312125.png" alt="" style="zoom:40%" /><p><strong>Eg: O(1): 交换x和y的值，是一个常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br></pre></td></tr></table></figure><p><strong>Eg: O(logN): 2<sup>k</sup> &#x3D; n,k是循环次数即算法复杂度，k &#x3D; logN</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Eg: O(nlogN)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;n)&#123;</span><br><span class="line">        x = x*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它时间复杂度指标：</p></li></ul></li></ul><img src="https://picbed.koko2pp.cc/image-20230107175332971.png" alt="" style="zoom:50%;" /><ul><li><p><strong>空间复杂度（内存增长的趋势）</strong></p><ul><li>常用空间复杂度：O(1), O(n), O(n<sup>2</sup>)</li><li><strong>Eg: O(1)</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br></pre></td></tr></table></figure><strong>Eg: O(n)，1D Array, 算法复杂度取决于newArray的长度，长度越大，需要分配的内存空间就越多</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    newArray[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>Eg: O(n^2)，计算Matrix，或者2D Array</strong></li></ul></li><li><p>计算：</p><img src="https://picbed.koko2pp.cc/image-20230107180552237.png" alt="image-20230107180552237" style="zoom:80%;" /><p>找变量和不变量，i++或者i–就是写本身，对于乘除写原表达式</p><p>例1中：变得是变量：{x&#x3D;x-10;y–}与x++，不变得是限制条件：while(y&gt;0){}与if(x&gt;100)中得0和100，先看外层： 左式(变)&#x3D;右式(不变)，最后相乘：y &#x3D; O(o)，x &#x3D; O(100)  y*x &#x3D; O(1)，复杂度为O(1)</p><p>例2中：i &#x3D; O(n),  j &#x3D; O(m)   →   最后相乘 复杂度为O(n*m)</p><p>例3中：i &#x3D; O(n),  j&#x3D;O(n), s&#x3D;O(1)   →   最后相乘 复杂度为O(n*n)</p><p>例4中：3<sup>i</sup>&#x3D; O(n) →  j &#x3D; O(log n)  →   最后复杂度为O(log n)</p></li></ul><h2 id="二、线性表（顺序表、链表）"><a href="#二、线性表（顺序表、链表）" class="headerlink" title="二、线性表（顺序表、链表）"></a>二、线性表（顺序表、链表）</h2><h3 id="2-1-线性表的定义、特点、基本操作"><a href="#2-1-线性表的定义、特点、基本操作" class="headerlink" title="2.1 线性表的定义、特点、基本操作"></a>2.1 线性表的定义、特点、基本操作</h3><h4 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h4><p>一个线性表是n个具有相同特性的数据元素的有限序列。</p><img src="https://picbed.koko2pp.cc/3cd109bd8e29e2ab0688da279fa147f.png" alt="3cd109bd8e29e2ab0688da279fa147f" style="zoom:67%;" /><h4 id="线性表的逻辑结构：线性结构"><a href="#线性表的逻辑结构：线性结构" class="headerlink" title="线性表的逻辑结构：线性结构"></a>线性表的逻辑结构：线性结构</h4><ul><li>在非空的线性表，有且仅有一个开始结点 a<sub>1</sub>，它没有直接前趋，且仅有一个直接后继a<sub>2</sub></li><li>有且仅有一个终端结点 a<sub>n</sub>，它没有直接后继，且仅有一个直接后继a<sub>n-1</sub></li><li>其余的内部结点( 2 ≤ i ≤ n-1)都有且仅有一个直接前趋a<sub>i-1</sub>和一个一个直接后继a<sub>i-1</sub></li></ul><h4 id="线性表的特点："><a href="#线性表的特点：" class="headerlink" title="线性表的特点："></a>线性表的特点：</h4><ul><li>元素<strong>个数有限</strong>（区别于数学中的集合，如自然数集合&#x2F;实数集合等是无限且无序）</li><li>元素逻辑上有顺序性，即<strong>元素间有先后次序</strong></li><li>元素都是数据元素，每个元素都是单个元素且<strong>数据类型相同，即每个元素占有相同大小的存储空间</strong></li><li>元素具有<strong>抽象性</strong>，只讨论元素间的逻辑关系，不管元素的具体内容</li></ul><h4 id="线性表的分类：顺序存储、链式存储"><a href="#线性表的分类：顺序存储、链式存储" class="headerlink" title="线性表的分类：顺序存储、链式存储"></a>线性表的分类：顺序存储、链式存储</h4><p>线性表指的是逻辑结构，元素之间1v1的线性关系；链式存储和顺序存储指的是存储结构；</p><img src="https://picbed.koko2pp.cc/image-20230108141904629.png" alt="" style="zoom:70%;" /><h4 id="线性表的基本操作："><a href="#线性表的基本操作：" class="headerlink" title="线性表的基本操作："></a>线性表的基本操作：</h4><img src="https://picbed.koko2pp.cc/image-20230108142840398.png" alt="image-20230108142840398" style="zoom:67%;" /><h3 id="2-2-线性表的顺序存储表示——顺序表"><a href="#2-2-线性表的顺序存储表示——顺序表" class="headerlink" title="2.2 线性表的顺序存储表示——顺序表"></a>2.2 线性表的顺序存储表示——顺序表</h3><h4 id="顺序表的定义：逻辑顺序与物理顺序相同"><a href="#顺序表的定义：逻辑顺序与物理顺序相同" class="headerlink" title="顺序表的定义：逻辑顺序与物理顺序相同"></a>顺序表的定义：逻辑顺序与物理顺序相同</h4><p>逻辑上相邻的数据元素存储在物理上相邻的存储单元的存储结构，即逻辑顺序与物理顺序相同。</p><img src="https://picbed.koko2pp.cc/image-20230108145335301.png" alt="image-20230108145335301" style="zoom:60%;" /><h4 id="顺序表中元素存储位置的计算：Loc-ai-x3D-Loc-a1-i-1-sizeof-ElemType"><a href="#顺序表中元素存储位置的计算：Loc-ai-x3D-Loc-a1-i-1-sizeof-ElemType" class="headerlink" title="顺序表中元素存储位置的计算：Loc(ai) &#x3D; Loc(a1)+(i-1)*sizeof(ElemType)"></a>顺序表中元素存储位置的计算：Loc(a<sub>i</sub>) &#x3D; Loc(a<sub>1</sub>)+(i-1)*sizeof(ElemType)</h4><img src="https://picbed.koko2pp.cc/00fbed045245e5e3c2ecf22fd218e01.jpg" alt="" style="zoom: 25%;" /><img src="https://picbed.koko2pp.cc/image-20230108145708935.png" alt="image-20230108145708935" style="zoom:63%;" /><h4 id="顺序表的特点：随机存取"><a href="#顺序表的特点：随机存取" class="headerlink" title="顺序表的特点：随机存取"></a>顺序表的特点：随机存取</h4><ul><li><p>主要特点是随机存取，<u>通过首地址和元素序号可在时间O(1)内找到任一元素</u></p></li><li><p>存储密度高，每个结点只存储数据元素</p></li><li><p>顺序表逻辑上相邻元素物理上也相邻，因此<u>插入和删除操作需要移动大量元素</u></p></li></ul><h4 id="顺序表的存储结构描述：静态分配-x2F-动态分配"><a href="#顺序表的存储结构描述：静态分配-x2F-动态分配" class="headerlink" title="顺序表的存储结构描述：静态分配&#x2F;动态分配"></a>顺序表的存储结构描述：静态分配&#x2F;动态分配</h4><p>一维数组可以<strong>静态分配</strong>，也可以<strong>动态分配</strong>。</p><p><strong>静态分配</strong>：由于数组大小和空间已提前固定，一旦空间占满，再加入新数据则造成溢出、程序崩溃；</p><p><strong>动态分配</strong>：<u>动态存储分配语句</u>进行存储数据的空间分配，<u>一旦空间占满，就另外开辟更大的存储空间去替换原存储空间以扩充存储数组空间</u>，不需要为线性表提前一次性地划分所有空间</p><ul><li><p>静态分配：假设线性表的元素类型为ElemType</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50<span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//顺序表的元素 使用数组表示</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义，使用该名称</span></span><br></pre></td></tr></table></figure></li><li><p>动态分配（依旧是顺序存储结构，物理结构没有变化）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100<span class="comment">//表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针(数组第一个元素所在位置的地址)</span></span><br><span class="line">    <span class="type">int</span> MaxSize,length;<span class="comment">//数组的最大容量和当前个数</span></span><br><span class="line">&#125;SqList;<span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C初始动态分配语句： (空间类型/指针类型)malloc(需要分配的空间大小)</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize);</span><br><span class="line"><span class="comment">//原型:分配长度为num-byte字节的内存块; 分配成功，则返回指向被分配的指针；分配失败，返回空指针NULL</span></span><br><span class="line"><span class="comment">//malloc函数通常与free函数成对使用，分配空间使用结束后使用free函数释放</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>*<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num-bytes)</span>;</span><br><span class="line"><span class="comment">//Eg:</span></span><br><span class="line"><span class="type">int</span> *A;</span><br><span class="line">A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>); <span class="comment">// A可以被当作做A[20]进行使用</span></span><br></pre></td></tr></table></figure><p>问题：InitSize&#x3D;10 即A[10]，放入15个元素，则动态分配的另外空间是A[5]&#x2F;A[10]&#x2F;A[15]？</p><p>答案：A[15]，要求逻辑上相邻的元素物理上也相邻，没有办法保证中间断开的两个元素的物理位置是相邻的，因此需要分配一个更大长度的连续物理存储空间放入所有元素</p></li></ul><h4 id="线性表的基本操作：插入O-n-x2F-删除O-n-x2F-查找-按位查找O-1-按值查找O-n"><a href="#线性表的基本操作：插入O-n-x2F-删除O-n-x2F-查找-按位查找O-1-按值查找O-n" class="headerlink" title="线性表的基本操作：插入O(n) &#x2F;删除O(n)&#x2F; 查找( 按位查找O(1) 按值查找O(n) )"></a>线性表的基本操作：插入O(n) &#x2F;删除O(n)&#x2F; 查找( 按位查找O(1) 按值查找O(n) )</h4><ul><li><p><strong>插入：</strong>在顺序表 L 的<strong>第 i ( 1 &lt;&#x3D; i &lt;&#x3D; L.length+1 )个位置</strong>插入新元素 e</p><p>若 i 的输入不合法，则返回 false，表示插入失败； </p><p>若 i 合法，则将第 i 个元素及其后面的所有元素一次向后移动一个位置，腾出一个空位插入新元素e，顺序表长度增加 1 ，插入成功，返回true;</p><p>或者插入失败 #define false 0; 插入成功 #define true 1; 那么<strong>bool</strong> ListInsert() 改为 <strong>int</strong> ListInsert()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作需要Input: 哪个顺序表(指针类型)，第几个元素进行插入，插入元素的值</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)<span class="comment">//首先判断是否合法，即判断i插入位置是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)<span class="comment">//看当前存储空间是否已满，若没满 还是可以继续插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;=i; j--)&#123;<span class="comment">//从最后一个元素开始，将第i个元素及之后的元素进行后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];<span class="comment">//把j-1位置的元素赋值给j位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;<span class="comment">//在位置i处放入e，i是位序，位序和下标差1</span></span><br><span class="line">    L.length++;<span class="comment">//线性表程度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.koko2pp.cc/image-20230108182819617.png" alt="image-20230108182819617" style="zoom:57%;" /><img src="https://picbed.koko2pp.cc/image-20230108184949032.png" alt="image-20230108184949032" style="zoom:57%;" /></p></li><li><p><strong>删除：</strong>删除顺序表L中<strong>第 i (1 &lt;&#x3D; i &lt;&#x3D; L.length)个位置的元素</strong>，用引用变量e返回。</p><p>输入不合法返回false；</p><p>输入合法，将被删除元素赋值给引用变量e (指针)，并将第i+1个元素及其后的所有元素依次向前移动一格位置，返回true;</p><p>先把删除结点内容赋值给变量e，数组的删除是<strong>覆盖操作</strong>， 原来的值(如图63)还会存在，但是length–，我们认为变化后的length长度为我们的表长，后面的63已经不在表内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *L, <span class="type">int</span> i, Elemtype *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)&#123;<span class="comment">//先判断i的范围是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length;j++)&#123;<span class="comment">//将第i个位置后的元素前移，提供的i是位置，j是下标</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//线性表长度减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.koko2pp.cc/image-20230108184120437.png" alt="image-20230108184120437" style="zoom:57%;" /><img src="https://picbed.koko2pp.cc/image-20230108184853875.png" alt="image-20230108184853875" style="zoom:57%;" /></p></li><li><p><strong>查找：</strong></p><p>按位查找（input位置 output值，直接找O(1)） 、按值查找（input值 output位置，需要从头遍历）</p><p><strong>按值查找：</strong>在顺序表L中查找<strong>第一个元素值等于 e 的元素</strong>，并<strong>返回其位序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(Sqlist L,ElemType e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;<span class="comment">//从头开始找 i = 0 开始，一直到L.length-1</span></span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//下标为i的元素值等于e，返回其位序 i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://picbed.koko2pp.cc/image-20230108190701727.png" alt="image-20230108190701727" style="zoom:40%;" /></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4>  <img src="https://picbed.koko2pp.cc/20230120223240.png" alt="20230120223240" style="zoom:20%;" />    <img src="https://picbed.koko2pp.cc/20230120223258.png" alt="20230120223258" style="zoom:15%;" /><h3 id="2-3-线性表的链式存储表示——链表-单链表"><a href="#2-3-线性表的链式存储表示——链表-单链表" class="headerlink" title="2.3 线性表的链式存储表示——链表(单链表)"></a>2.3 线性表的链式存储表示——链表(单链表)</h3><p>由于<u>顺序表的插入、删除操作需要移动大量元素</u>，因此引入链式存储结构的线性表。<strong>链表不需要使用地址连续的存储单元，通过指针建立起数据元素之间的逻辑关系</strong>，因此插入和删除不需要移动元素，只需要<strong>修改指针</strong>，也因此<u>失去了顺序表随机存取的优点</u>。</p><h4 id="链表-单链表-x2F-双链表-x2F-循环链表的定义："><a href="#链表-单链表-x2F-双链表-x2F-循环链表的定义：" class="headerlink" title="链表(单链表)&#x2F;双链表&#x2F;循环链表的定义："></a>链表(单链表)&#x2F;双链表&#x2F;循环链表的定义：</h4><ul><li><p>线性表的<strong>链式存储又称为单链表</strong>，即通过一组任意存储单元来存数据元素。每个链表结点由<strong>数据域</strong>（存放元素数值数据）和<strong>指针域</strong>（存储直接后继节点的指针 ）构成</p><p>单链表的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct LNode&#123;<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    stuct LNode *next;<span class="comment">//指针域（指向下一个结点的指针）</span></span><br><span class="line">&#125;LNode,*LinkList;<span class="comment">//LNode普通类型，*LinkList为指针类型，Linklist A;和LNode *B; 类型等价</span></span><br></pre></td></tr></table></figure><p>结点<u>只有一个指针域</u>的链表为单链表</p><img src="https://picbed.koko2pp.cc/image-20230108205033986.png" alt="image-20230108205033986" style="zoom:80%;" /></li><li><p>双链表：结点有<u>两个指针域</u>的链表</p><img src="https://picbed.koko2pp.cc/image-20230108205103948.png" alt="image-20230108205103948" style="zoom:80%;" /></li><li><p>循环链表：<u>首尾相接</u>的单链表</p><img src="https://picbed.koko2pp.cc/image-20230108205128475.png" alt="image-20230108205128475" style="zoom:80%;" /></li></ul><h4 id="链表的头指针、头结点、首元结点的定义："><a href="#链表的头指针、头结点、首元结点的定义：" class="headerlink" title="链表的头指针、头结点、首元结点的定义："></a>链表的头指针、头结点、首元结点的定义：</h4><p>使用<strong>头指针</strong>来标识一个单链表（Eg：单链表L，头指针为NULL的时候表示为一个空表），在单链表第一个结点之前附加一个结点，称为<strong>头结点</strong>，头结点的数据域可以不放任何信息，也可以用于记录表长，头结点的指针域指向线性表的<strong>首元结点</strong>（第一个元素结点）。 <u>头结点可以有可无</u></p><img src="https://picbed.koko2pp.cc/image-20230108205338932.png" alt="image-20230108205338932" style="zoom:55%;" /><img src="https://picbed.koko2pp.cc/image-20230108210235792.png" alt="image-20230108210235792" style="zoom:63%;" /><h4 id="链表的基本操作：创建链表O-n-头插法-x2F-尾插法、删除、查找O-n-按序-x2F-按值"><a href="#链表的基本操作：创建链表O-n-头插法-x2F-尾插法、删除、查找O-n-按序-x2F-按值" class="headerlink" title="链表的基本操作：创建链表O(n)(头插法&#x2F;尾插法、删除、查找O(n)(按序&#x2F;按值)"></a>链表的基本操作：创建链表O(n)(头插法&#x2F;尾插法、删除、查找O(n)(按序&#x2F;按值)</h4><ul><li><p><strong>创建链表</strong></p><ul><li><p><strong>头插法</strong>：从一个空表开始生成新结点，并将读取到的数据存放到新结点的数据域中，然后**将新结点插入到当前链表的<u>表头，即头结点之后</u>**。 </p><p>（需要**<u>先操作后端，再操作前端</u>**，如图，在表头插入a<sub>i</sub>新结点，首先将a<sub>i</sub>的指针域指向原来的首元结点a<sub>l</sub>，再将头结点的指针域指向a<sub>i</sub>；错误做法：先前端再后端，先将头结点的指针指向a<sub>i</sub>，则此时丢失了指向a<sub>l</sub>的指针域，即无法找到a<sub>l</sub>结点）</p><p>头插法输出后得到的是一个<strong>倒序的序列</strong></p><p><img src="https://picbed.koko2pp.cc/image-20230108211504514.png" alt="image-20230108211504514" style="zoom:57%;" /><img src="https://picbed.koko2pp.cc/image-20230108230623649.png" alt="image-20230108230623649" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123; <span class="comment">//输入：头指针，输出LinkList类型的链表</span></span><br><span class="line">    <span class="comment">//逆向建立单链表：</span></span><br><span class="line">    LNode *s; <span class="type">int</span> x; <span class="comment">// 新结点s以及新结点存放的数据x</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点，指针类型</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点赋空，初始化为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示循环/插入结束</span></span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新结点s</span></span><br><span class="line">        s-&gt;data = x;<span class="comment">//把x赋值给s结点的数据域</span></span><br><span class="line">        s-&gt;next = L-&gt;next;<span class="comment">//先操作后端</span></span><br><span class="line">        L-&gt;next = s;<span class="comment">//再操作前端，将新结点插入链表，L头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个结点插入时间为O(1)，设单链表的表长为n，则<strong>总时间复杂度为O(n)</strong></p><p>思考：若<strong>没有设立头结点</strong>，则修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入：头指针L，输出LinkList类型</span></span><br><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;<span class="comment">//逆向建立单链表：</span></span><br><span class="line">    LNode *s; <span class="type">int</span> x; <span class="comment">// 新结点s以及新结点存放的数据x</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点，指针类型</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示循环/插入结束</span></span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新结点s</span></span><br><span class="line">        s-&gt;data = x;<span class="comment">//把x赋值给s结点的数据域</span></span><br><span class="line">        <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            L = s;<span class="comment">//先操作后端</span></span><br><span class="line">            s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//再操作前端</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s-&gt;next = L;<span class="comment">//先操作后端</span></span><br><span class="line">            L = s;<span class="comment">//再操作前端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：如果不设置头结点，L头指针就直接指向第一个结点（L&#x3D;s）；设置了头结点则头指针存放在头结点的指针域中，当作一个结点使用  (L-&gt;next &#x3D; s)</p></li><li><p><strong>尾插法：</strong>尾插法生成的链表中，结点的次序和输入数据的顺序一致。该方法将新结点插入当前链表的表尾，因此<strong>需要一个尾指针 r ，使其始终指向当前链表的尾结点</strong></p><p>依然先操作后端再操作前端：先将a<sub>j</sub>的指针域NULL赋给a<sub>i</sub>的后端，再将a<sub>i</sub>的结点地址赋给a<sub>j</sub>的指针域</p><p><img src="https://picbed.koko2pp.cc/image-20230108233100283.png" alt="image-20230108233100283" style="zoom:60%;" /><img src="https://picbed.koko2pp.cc/image-20230108233454888.png" alt="image-20230108233454888" style="zoom:67%;" />      </p><p>①   <img src="https://picbed.koko2pp.cc/image-20230108233913488.png" alt="image-20230108233913488" style="zoom:67%;" /> ②<img src="https://picbed.koko2pp.cc/image-20230108234236458.png" alt="image-20230108234236458" style="zoom:67%;" />③<img src="https://picbed.koko2pp.cc/image-20230108234302176.png" alt="image-20230108234302176" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入：头指针L，输出LinkList类型</span></span><br><span class="line">LinkList List <span class="title function_">TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;<span class="comment">//设元素类型为整形</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    LNode *s, *r=L;<span class="comment">//① r为表尾指针(上面右图 和L一样指向头节点）</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//新结点</span></span><br><span class="line">        s-&gt;data = x;<span class="comment">//新结点数据域</span></span><br><span class="line">        r-&gt;next = s; <span class="comment">//② 最后结点的指针域指向s，连接尾结点和s结点</span></span><br><span class="line">        r = s;<span class="comment">//③ r指向新的表尾结点s</span></span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为附设了一个指向表尾结点的指针，因此时间复杂度和头插法相同为<strong>O(n)</strong></p></li></ul></li><li><p><strong>查找</strong>：复杂度为O(n)</p><ul><li><p><strong>按序查找</strong>：<u>从第一个结点出发，顺着指针next域逐个向下搜索，知道找到第i个结点为止</u>，否则返回最后一个结点指针域NULL。 遍历操作，复杂度为O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入：链表 序号；输出：结点</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>; <span class="comment">//计数，初始为1</span></span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">//移动的指针,L指向头结点，p此时指向的是第一个数据结点即首元结点</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;<span class="comment">//若i等于0，返回头结点</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//若i不合法，返回NULL</span></span><br><span class="line">    <span class="comment">//这里p等价于p→next!=null，while循环进行判断，如果p不等于空且j&lt;i（即没到尾节点并且还没有查到i节点）判断为真，继续执行循环;若p指向NULL即P已经是尾结点，跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<span class="comment">//从第一个结点开始找，找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;<span class="comment">//</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按值查找：从表的第一个结点开始，从前往后依次比较各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有该结点，则返回NULL。遍历操作，复杂度为O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=e)&#123; <span class="comment">//从第一个结点开始查找data域为e的结点</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//找到后返回该指针，不然返回NULL(p此时是尾结点，返回尾结点的指针域)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>插入 O(n)</strong></p><ul><li><p>将值为 x 的新结点插入到单链表的第 i 个位置上。先检查插入位置的合法性，**找到带插入位置的<u>前驱节点</u>**，即第 i-1 个结点，再在其后插入新结点。 算法：首先调用按序查找函数找到第 i-1 个结点GetElem(L, i-1)，返回的是第 i-1 个结点为 *p ，让新结点 *s 的指针域指向 *p 的后继节点，再令结点 *p 的指针域指向新插入的结点 *s</p><img src="https://picbed.koko2pp.cc/image-20230111123256478.png" alt="image-20230111123256478" style="zoom:50%;" /><img src="https://picbed.koko2pp.cc/image-20230112170213266.png" alt="image-20230112170213266" style="zoom:70%;" /></li></ul></li><li><p><strong>删除结点操作</strong></p><ul><li><p>删除结点操作是将单链表的第 i 个结点删除。先检查删除位置的合法性，后查找表中第 i-1 个结点，即被删结点的前驱节点，再将其删除</p><img src="https://picbed.koko2pp.cc/image-20230112172744627.png" alt="image-20230112172744627" style="zoom:70%;" /><img src="https://picbed.koko2pp.cc/image-20230112173023710.png" alt="image-20230112173023710" style="zoom:77%;" /></li></ul></li><li><p><strong>求表长</strong>：计数器，算法复杂度为O(n)</p></li></ul><h4 id="双链表及双链表的基本操作-插入O-1-删除O-1"><a href="#双链表及双链表的基本操作-插入O-1-删除O-1" class="headerlink" title="双链表及双链表的基本操作 插入O(1) 删除O(1)"></a>双链表及双链表的基本操作 插入O(1) 删除O(1)</h4><p>已知单链表中访问某结点的前驱结点（插入、删除操作），只能够从头遍历。为克服该缺点，引入双链表：双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点</p><img src="https://picbed.koko2pp.cc/image-20230112173500926.png" alt="image-20230112173500926" style="zoom:67%;" /><p>双链表中结点类型的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span><span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span><span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure><ul><li><p>双链表的插入操作</p><p>为了不断链，同样是先后端再前端：</p><img src="https://picbed.koko2pp.cc/image-20230112174351490.png" alt="image-20230112174351490" style="zoom:65%;" /></li><li><p>双链表的删除操作</p><img src="https://picbed.koko2pp.cc/image-20230112174614214.png" alt="image-20230112174614214" style="zoom:70%;" /></li></ul><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环链表中，**最后一个结点的指针不是NULL，而改为<u>指向头结点</u>**，整个链表形成一个环。</p><p>循环单链表中，表尾结点<em>r的next域指向L，因此表中没有指针域为NULL的结点，因此*<em>循环单链表的<u>判空条件</u>不是头结点是否为空，而是判断它是否等于头指针</em></em></p><img src="https://picbed.koko2pp.cc/image-20230112180618280.png" alt="image-20230112180618280" style="zoom:57%;" /><img src="https://picbed.koko2pp.cc/image-20230112180635258.png" alt="image-20230112180635258" style="zoom:80%;" /><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><img src="https://picbed.koko2pp.cc/image-20230112180820291.png" alt="image-20230112180820291" style="zoom:67%;" /><h4 id="链表的总结"><a href="#链表的总结" class="headerlink" title="链表的总结"></a>链表的总结</h4><img src="https://picbed.koko2pp.cc/image-20230112182235386.png" alt="image-20230112182235386" style="zoom:60%;" /><h4 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h4><img src="https://picbed.koko2pp.cc/image-20230112182319550.png" alt="image-20230112182319550" style="zoom:50%;" /><img src="https://picbed.koko2pp.cc/image-20230112182455628.png" alt="image-20230112182455628" style="zoom:55%;" /><img src="https://picbed.koko2pp.cc/image-20230112182531931.png" alt="image-20230112182531931" style="zoom:53%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章-test"><a href="#这是我的第三篇文章-test" class="headerlink" title="这是我的第三篇文章 test"></a>这是我的第三篇文章 test</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章-test"><a href="#这是我的第一篇文章-test" class="headerlink" title="这是我的第一篇文章 test"></a>这是我的第一篇文章 test</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
